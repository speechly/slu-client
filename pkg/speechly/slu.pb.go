// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: slu.proto

package speechly

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Choice of audio encodings.
type SLUConfig_Encoding int32

const (
	SLUConfig_LINEAR16 SLUConfig_Encoding = 0
)

var SLUConfig_Encoding_name = map[int32]string{
	0: "LINEAR16",
}

var SLUConfig_Encoding_value = map[string]int32{
	"LINEAR16": 0,
}

func (x SLUConfig_Encoding) String() string {
	return proto.EnumName(SLUConfig_Encoding_name, int32(x))
}

func (SLUConfig_Encoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{1, 0}
}

type SLUEvent_Event int32

const (
	// Starts a new audio context
	SLUEvent_START SLUEvent_Event = 0
	// Stops an audio context
	SLUEvent_STOP SLUEvent_Event = 1
)

var SLUEvent_Event_name = map[int32]string{
	0: "START",
	1: "STOP",
}

var SLUEvent_Event_value = map[string]int32{
	"START": 0,
	"STOP":  1,
}

func (x SLUEvent_Event) String() string {
	return proto.EnumName(SLUEvent_Event_name, int32(x))
}

func (SLUEvent_Event) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{2, 0}
}

// The message repeatedly sent by the client of `Slu.Stream`.
//
// When a new `Slu.Stream` stream is started, the client must first
// send the `config` value, which configures the SLU engine. If it is
// not the first message sent, the stream will close with an error.
//
// After the configuration has done, the stream is in an "audio loop"
// state. Where the user sends `event` messages as a control signal,
// e.g. to start and stop a single utterance. And the user streams
// audio as `audio` value when an utterance is ongoing.
//
// The basic audio loop is:
// - Client sends `SluEvent.Event.START` event when the user wants to
//   start speaking.
// - Server sends `SluResponse.started` when it's ready to receive
//   audio for an utterance.
// - Client sends audio chunks. Chunks must be under one megabyte.
// - Server sends `SluReponses` for events and utterance results.
// - Client sends `SluEvent.Event.STOP` event when no more audio is to
//   be sent for this utterance.
// - Server processed all audio received until stop, and sends
//   utterance results. Finishing with `finished response`.
//
// Only one utterance can be active at a time, but the old utterances
// can still concurrently send results.
//
// If `SluEvent.Event.START` is send before stopping the current
// on-going utterance with `SluEvent.Event.STOP` the whole stream is
// killed with an error. This is to ensure that the clients are well
// behaved.
//
// See `SLUResponse` for info on server sent messages.
type SLURequest struct {
	// Types that are valid to be assigned to StreamingRequest:
	//	*SLURequest_Config
	//	*SLURequest_Event
	//	*SLURequest_Audio
	StreamingRequest isSLURequest_StreamingRequest `protobuf_oneof:"streaming_request"`
}

func (m *SLURequest) Reset()         { *m = SLURequest{} }
func (m *SLURequest) String() string { return proto.CompactTextString(m) }
func (*SLURequest) ProtoMessage()    {}
func (*SLURequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{0}
}
func (m *SLURequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLURequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLURequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLURequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLURequest.Merge(m, src)
}
func (m *SLURequest) XXX_Size() int {
	return m.Size()
}
func (m *SLURequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SLURequest.DiscardUnknown(m)
}

var xxx_messageInfo_SLURequest proto.InternalMessageInfo

type isSLURequest_StreamingRequest interface {
	isSLURequest_StreamingRequest()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SLURequest_Config struct {
	Config *SLUConfig `protobuf:"bytes,1,opt,name=config,proto3,oneof" json:"config,omitempty"`
}
type SLURequest_Event struct {
	Event *SLUEvent `protobuf:"bytes,2,opt,name=event,proto3,oneof" json:"event,omitempty"`
}
type SLURequest_Audio struct {
	Audio []byte `protobuf:"bytes,3,opt,name=audio,proto3,oneof" json:"audio,omitempty"`
}

func (*SLURequest_Config) isSLURequest_StreamingRequest() {}
func (*SLURequest_Event) isSLURequest_StreamingRequest()  {}
func (*SLURequest_Audio) isSLURequest_StreamingRequest()  {}

func (m *SLURequest) GetStreamingRequest() isSLURequest_StreamingRequest {
	if m != nil {
		return m.StreamingRequest
	}
	return nil
}

func (m *SLURequest) GetConfig() *SLUConfig {
	if x, ok := m.GetStreamingRequest().(*SLURequest_Config); ok {
		return x.Config
	}
	return nil
}

func (m *SLURequest) GetEvent() *SLUEvent {
	if x, ok := m.GetStreamingRequest().(*SLURequest_Event); ok {
		return x.Event
	}
	return nil
}

func (m *SLURequest) GetAudio() []byte {
	if x, ok := m.GetStreamingRequest().(*SLURequest_Audio); ok {
		return x.Audio
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SLURequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SLURequest_Config)(nil),
		(*SLURequest_Event)(nil),
		(*SLURequest_Audio)(nil),
	}
}

// Message to configure the speech recognition engine.
//
// This message must be sent as the first message in `Slu.Stream` RPC.
type SLUConfig struct {
	// The encoding used for the audio stream, defaults to the first
	// item in `Encoding`.
	Encoding SLUConfig_Encoding `protobuf:"varint,1,opt,name=encoding,proto3,enum=speechly.slu.v1.SLUConfig_Encoding" json:"encoding,omitempty"`
	// *Required* Channels in the audio stream, must be at least 1.
	Channels int32 `protobuf:"varint,2,opt,name=channels,proto3" json:"channels,omitempty"`
	// *Required* Sample rate of the audio stream. 16000Hz is
	// preferred, 8000Hz is the minimum rate.
	SampleRateHertz int32 `protobuf:"varint,3,opt,name=sample_rate_hertz,json=sampleRateHertz,proto3" json:"sample_rate_hertz,omitempty"`
	// *Required* Language code for speech recognition. Must match one
	// of the languages defined in the appId configuration.
	LanguageCode string `protobuf:"bytes,4,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
}

func (m *SLUConfig) Reset()         { *m = SLUConfig{} }
func (m *SLUConfig) String() string { return proto.CompactTextString(m) }
func (*SLUConfig) ProtoMessage()    {}
func (*SLUConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{1}
}
func (m *SLUConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUConfig.Merge(m, src)
}
func (m *SLUConfig) XXX_Size() int {
	return m.Size()
}
func (m *SLUConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SLUConfig proto.InternalMessageInfo

func (m *SLUConfig) GetEncoding() SLUConfig_Encoding {
	if m != nil {
		return m.Encoding
	}
	return SLUConfig_LINEAR16
}

func (m *SLUConfig) GetChannels() int32 {
	if m != nil {
		return m.Channels
	}
	return 0
}

func (m *SLUConfig) GetSampleRateHertz() int32 {
	if m != nil {
		return m.SampleRateHertz
	}
	return 0
}

func (m *SLUConfig) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

// Control event send by the client in `Slu.Stream` RPC.
type SLUEvent struct {
	Event SLUEvent_Event `protobuf:"varint,1,opt,name=event,proto3,enum=speechly.slu.v1.SLUEvent_Event" json:"event,omitempty"`
}

func (m *SLUEvent) Reset()         { *m = SLUEvent{} }
func (m *SLUEvent) String() string { return proto.CompactTextString(m) }
func (*SLUEvent) ProtoMessage()    {}
func (*SLUEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{2}
}
func (m *SLUEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUEvent.Merge(m, src)
}
func (m *SLUEvent) XXX_Size() int {
	return m.Size()
}
func (m *SLUEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SLUEvent proto.InternalMessageInfo

func (m *SLUEvent) GetEvent() SLUEvent_Event {
	if m != nil {
		return m.Event
	}
	return SLUEvent_START
}

// Message sent by the server in `Slu.Stream` RPC.
//
// When an utterance is started, the server sends the `SluStarted`
// message, which contains an `audio_context` for matching rest of the
// response messages to that specific utterance.
//
// As the audio is processed, the server sends `TranscriptEvent` messages
// continuously.
//
// `SluFinished` is sent when an audio context is finished, either by the
// client stopping the utterance, or by an error.
type SLUResponse struct {
	// The identifier to match server responses to an audio context.
	AudioContext string `protobuf:"bytes,1,opt,name=audio_context,json=audioContext,proto3" json:"audio_context,omitempty"`
	SegmentId    int32  `protobuf:"varint,2,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty"`
	// Types that are valid to be assigned to StreamingResponse:
	//	*SLUResponse_Transcript
	//	*SLUResponse_Entity
	//	*SLUResponse_Intent
	//	*SLUResponse_SegmentEnd
	//	*SLUResponse_TentativeTranscript
	//	*SLUResponse_TentativeEntities
	//	*SLUResponse_TentativeIntent
	//	*SLUResponse_Started
	//	*SLUResponse_Finished
	StreamingResponse isSLUResponse_StreamingResponse `protobuf_oneof:"streaming_response"`
}

func (m *SLUResponse) Reset()         { *m = SLUResponse{} }
func (m *SLUResponse) String() string { return proto.CompactTextString(m) }
func (*SLUResponse) ProtoMessage()    {}
func (*SLUResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{3}
}
func (m *SLUResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUResponse.Merge(m, src)
}
func (m *SLUResponse) XXX_Size() int {
	return m.Size()
}
func (m *SLUResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SLUResponse proto.InternalMessageInfo

type isSLUResponse_StreamingResponse interface {
	isSLUResponse_StreamingResponse()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SLUResponse_Transcript struct {
	Transcript *SLUTranscript `protobuf:"bytes,3,opt,name=transcript,proto3,oneof" json:"transcript,omitempty"`
}
type SLUResponse_Entity struct {
	Entity *SLUEntity `protobuf:"bytes,4,opt,name=entity,proto3,oneof" json:"entity,omitempty"`
}
type SLUResponse_Intent struct {
	Intent *SLUIntent `protobuf:"bytes,5,opt,name=intent,proto3,oneof" json:"intent,omitempty"`
}
type SLUResponse_SegmentEnd struct {
	SegmentEnd *SLUSegmentEnd `protobuf:"bytes,6,opt,name=segment_end,json=segmentEnd,proto3,oneof" json:"segment_end,omitempty"`
}
type SLUResponse_TentativeTranscript struct {
	TentativeTranscript *SLUTentativeTranscript `protobuf:"bytes,7,opt,name=tentative_transcript,json=tentativeTranscript,proto3,oneof" json:"tentative_transcript,omitempty"`
}
type SLUResponse_TentativeEntities struct {
	TentativeEntities *SLUTentativeEntities `protobuf:"bytes,8,opt,name=tentative_entities,json=tentativeEntities,proto3,oneof" json:"tentative_entities,omitempty"`
}
type SLUResponse_TentativeIntent struct {
	TentativeIntent *SLUIntent `protobuf:"bytes,9,opt,name=tentative_intent,json=tentativeIntent,proto3,oneof" json:"tentative_intent,omitempty"`
}
type SLUResponse_Started struct {
	Started *SLUStarted `protobuf:"bytes,10,opt,name=started,proto3,oneof" json:"started,omitempty"`
}
type SLUResponse_Finished struct {
	Finished *SLUFinished `protobuf:"bytes,11,opt,name=finished,proto3,oneof" json:"finished,omitempty"`
}

func (*SLUResponse_Transcript) isSLUResponse_StreamingResponse()          {}
func (*SLUResponse_Entity) isSLUResponse_StreamingResponse()              {}
func (*SLUResponse_Intent) isSLUResponse_StreamingResponse()              {}
func (*SLUResponse_SegmentEnd) isSLUResponse_StreamingResponse()          {}
func (*SLUResponse_TentativeTranscript) isSLUResponse_StreamingResponse() {}
func (*SLUResponse_TentativeEntities) isSLUResponse_StreamingResponse()   {}
func (*SLUResponse_TentativeIntent) isSLUResponse_StreamingResponse()     {}
func (*SLUResponse_Started) isSLUResponse_StreamingResponse()             {}
func (*SLUResponse_Finished) isSLUResponse_StreamingResponse()            {}

func (m *SLUResponse) GetStreamingResponse() isSLUResponse_StreamingResponse {
	if m != nil {
		return m.StreamingResponse
	}
	return nil
}

func (m *SLUResponse) GetAudioContext() string {
	if m != nil {
		return m.AudioContext
	}
	return ""
}

func (m *SLUResponse) GetSegmentId() int32 {
	if m != nil {
		return m.SegmentId
	}
	return 0
}

func (m *SLUResponse) GetTranscript() *SLUTranscript {
	if x, ok := m.GetStreamingResponse().(*SLUResponse_Transcript); ok {
		return x.Transcript
	}
	return nil
}

func (m *SLUResponse) GetEntity() *SLUEntity {
	if x, ok := m.GetStreamingResponse().(*SLUResponse_Entity); ok {
		return x.Entity
	}
	return nil
}

func (m *SLUResponse) GetIntent() *SLUIntent {
	if x, ok := m.GetStreamingResponse().(*SLUResponse_Intent); ok {
		return x.Intent
	}
	return nil
}

func (m *SLUResponse) GetSegmentEnd() *SLUSegmentEnd {
	if x, ok := m.GetStreamingResponse().(*SLUResponse_SegmentEnd); ok {
		return x.SegmentEnd
	}
	return nil
}

func (m *SLUResponse) GetTentativeTranscript() *SLUTentativeTranscript {
	if x, ok := m.GetStreamingResponse().(*SLUResponse_TentativeTranscript); ok {
		return x.TentativeTranscript
	}
	return nil
}

func (m *SLUResponse) GetTentativeEntities() *SLUTentativeEntities {
	if x, ok := m.GetStreamingResponse().(*SLUResponse_TentativeEntities); ok {
		return x.TentativeEntities
	}
	return nil
}

func (m *SLUResponse) GetTentativeIntent() *SLUIntent {
	if x, ok := m.GetStreamingResponse().(*SLUResponse_TentativeIntent); ok {
		return x.TentativeIntent
	}
	return nil
}

func (m *SLUResponse) GetStarted() *SLUStarted {
	if x, ok := m.GetStreamingResponse().(*SLUResponse_Started); ok {
		return x.Started
	}
	return nil
}

func (m *SLUResponse) GetFinished() *SLUFinished {
	if x, ok := m.GetStreamingResponse().(*SLUResponse_Finished); ok {
		return x.Finished
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SLUResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SLUResponse_Transcript)(nil),
		(*SLUResponse_Entity)(nil),
		(*SLUResponse_Intent)(nil),
		(*SLUResponse_SegmentEnd)(nil),
		(*SLUResponse_TentativeTranscript)(nil),
		(*SLUResponse_TentativeEntities)(nil),
		(*SLUResponse_TentativeIntent)(nil),
		(*SLUResponse_Started)(nil),
		(*SLUResponse_Finished)(nil),
	}
}

type SLUTranscript struct {
	Word      string `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
	Index     int32  `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	StartTime int32  `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int32  `protobuf:"varint,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *SLUTranscript) Reset()         { *m = SLUTranscript{} }
func (m *SLUTranscript) String() string { return proto.CompactTextString(m) }
func (*SLUTranscript) ProtoMessage()    {}
func (*SLUTranscript) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{4}
}
func (m *SLUTranscript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUTranscript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUTranscript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUTranscript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUTranscript.Merge(m, src)
}
func (m *SLUTranscript) XXX_Size() int {
	return m.Size()
}
func (m *SLUTranscript) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUTranscript.DiscardUnknown(m)
}

var xxx_messageInfo_SLUTranscript proto.InternalMessageInfo

func (m *SLUTranscript) GetWord() string {
	if m != nil {
		return m.Word
	}
	return ""
}

func (m *SLUTranscript) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SLUTranscript) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *SLUTranscript) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type SLUEntity struct {
	Entity        string `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	StartPosition int32  `protobuf:"varint,3,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
	EndPosition   int32  `protobuf:"varint,4,opt,name=end_position,json=endPosition,proto3" json:"end_position,omitempty"`
}

func (m *SLUEntity) Reset()         { *m = SLUEntity{} }
func (m *SLUEntity) String() string { return proto.CompactTextString(m) }
func (*SLUEntity) ProtoMessage()    {}
func (*SLUEntity) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{5}
}
func (m *SLUEntity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUEntity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUEntity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUEntity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUEntity.Merge(m, src)
}
func (m *SLUEntity) XXX_Size() int {
	return m.Size()
}
func (m *SLUEntity) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUEntity.DiscardUnknown(m)
}

var xxx_messageInfo_SLUEntity proto.InternalMessageInfo

func (m *SLUEntity) GetEntity() string {
	if m != nil {
		return m.Entity
	}
	return ""
}

func (m *SLUEntity) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *SLUEntity) GetStartPosition() int32 {
	if m != nil {
		return m.StartPosition
	}
	return 0
}

func (m *SLUEntity) GetEndPosition() int32 {
	if m != nil {
		return m.EndPosition
	}
	return 0
}

type SLUIntent struct {
	Intent string `protobuf:"bytes,1,opt,name=intent,proto3" json:"intent,omitempty"`
}

func (m *SLUIntent) Reset()         { *m = SLUIntent{} }
func (m *SLUIntent) String() string { return proto.CompactTextString(m) }
func (*SLUIntent) ProtoMessage()    {}
func (*SLUIntent) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{6}
}
func (m *SLUIntent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUIntent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUIntent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUIntent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUIntent.Merge(m, src)
}
func (m *SLUIntent) XXX_Size() int {
	return m.Size()
}
func (m *SLUIntent) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUIntent.DiscardUnknown(m)
}

var xxx_messageInfo_SLUIntent proto.InternalMessageInfo

func (m *SLUIntent) GetIntent() string {
	if m != nil {
		return m.Intent
	}
	return ""
}

type SLUSegmentEnd struct {
}

func (m *SLUSegmentEnd) Reset()         { *m = SLUSegmentEnd{} }
func (m *SLUSegmentEnd) String() string { return proto.CompactTextString(m) }
func (*SLUSegmentEnd) ProtoMessage()    {}
func (*SLUSegmentEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{7}
}
func (m *SLUSegmentEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUSegmentEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUSegmentEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUSegmentEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUSegmentEnd.Merge(m, src)
}
func (m *SLUSegmentEnd) XXX_Size() int {
	return m.Size()
}
func (m *SLUSegmentEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUSegmentEnd.DiscardUnknown(m)
}

var xxx_messageInfo_SLUSegmentEnd proto.InternalMessageInfo

type SLUTentativeTranscript struct {
	TentativeTranscript string           `protobuf:"bytes,1,opt,name=tentative_transcript,json=tentativeTranscript,proto3" json:"tentative_transcript,omitempty"`
	TentativeWords      []*SLUTranscript `protobuf:"bytes,2,rep,name=tentative_words,json=tentativeWords,proto3" json:"tentative_words,omitempty"`
}

func (m *SLUTentativeTranscript) Reset()         { *m = SLUTentativeTranscript{} }
func (m *SLUTentativeTranscript) String() string { return proto.CompactTextString(m) }
func (*SLUTentativeTranscript) ProtoMessage()    {}
func (*SLUTentativeTranscript) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{8}
}
func (m *SLUTentativeTranscript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUTentativeTranscript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUTentativeTranscript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUTentativeTranscript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUTentativeTranscript.Merge(m, src)
}
func (m *SLUTentativeTranscript) XXX_Size() int {
	return m.Size()
}
func (m *SLUTentativeTranscript) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUTentativeTranscript.DiscardUnknown(m)
}

var xxx_messageInfo_SLUTentativeTranscript proto.InternalMessageInfo

func (m *SLUTentativeTranscript) GetTentativeTranscript() string {
	if m != nil {
		return m.TentativeTranscript
	}
	return ""
}

func (m *SLUTentativeTranscript) GetTentativeWords() []*SLUTranscript {
	if m != nil {
		return m.TentativeWords
	}
	return nil
}

type SLUTentativeEntities struct {
	TentativeEntities []*SLUEntity `protobuf:"bytes,1,rep,name=tentative_entities,json=tentativeEntities,proto3" json:"tentative_entities,omitempty"`
}

func (m *SLUTentativeEntities) Reset()         { *m = SLUTentativeEntities{} }
func (m *SLUTentativeEntities) String() string { return proto.CompactTextString(m) }
func (*SLUTentativeEntities) ProtoMessage()    {}
func (*SLUTentativeEntities) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{9}
}
func (m *SLUTentativeEntities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUTentativeEntities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUTentativeEntities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUTentativeEntities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUTentativeEntities.Merge(m, src)
}
func (m *SLUTentativeEntities) XXX_Size() int {
	return m.Size()
}
func (m *SLUTentativeEntities) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUTentativeEntities.DiscardUnknown(m)
}

var xxx_messageInfo_SLUTentativeEntities proto.InternalMessageInfo

func (m *SLUTentativeEntities) GetTentativeEntities() []*SLUEntity {
	if m != nil {
		return m.TentativeEntities
	}
	return nil
}

// Message sent when a new audio context has started.
type SLUStarted struct {
}

func (m *SLUStarted) Reset()         { *m = SLUStarted{} }
func (m *SLUStarted) String() string { return proto.CompactTextString(m) }
func (*SLUStarted) ProtoMessage()    {}
func (*SLUStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{10}
}
func (m *SLUStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUStarted.Merge(m, src)
}
func (m *SLUStarted) XXX_Size() int {
	return m.Size()
}
func (m *SLUStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUStarted.DiscardUnknown(m)
}

var xxx_messageInfo_SLUStarted proto.InternalMessageInfo

// Message sent when an audio context is finished.
type SLUFinished struct {
	// If the audio context finished with an error, then this field contains a value.
	Error *SLUError `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *SLUFinished) Reset()         { *m = SLUFinished{} }
func (m *SLUFinished) String() string { return proto.CompactTextString(m) }
func (*SLUFinished) ProtoMessage()    {}
func (*SLUFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{11}
}
func (m *SLUFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUFinished.Merge(m, src)
}
func (m *SLUFinished) XXX_Size() int {
	return m.Size()
}
func (m *SLUFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUFinished.DiscardUnknown(m)
}

var xxx_messageInfo_SLUFinished proto.InternalMessageInfo

func (m *SLUFinished) GetError() *SLUError {
	if m != nil {
		return m.Error
	}
	return nil
}

// Message for errors
type SLUError struct {
	// Short code for the error
	Code string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	// Human readable explanation of the error
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *SLUError) Reset()         { *m = SLUError{} }
func (m *SLUError) String() string { return proto.CompactTextString(m) }
func (*SLUError) ProtoMessage()    {}
func (*SLUError) Descriptor() ([]byte, []int) {
	return fileDescriptor_b3c6a5efd6c2ea4f, []int{12}
}
func (m *SLUError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SLUError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SLUError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SLUError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLUError.Merge(m, src)
}
func (m *SLUError) XXX_Size() int {
	return m.Size()
}
func (m *SLUError) XXX_DiscardUnknown() {
	xxx_messageInfo_SLUError.DiscardUnknown(m)
}

var xxx_messageInfo_SLUError proto.InternalMessageInfo

func (m *SLUError) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *SLUError) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("speechly.slu.v1.SLUConfig_Encoding", SLUConfig_Encoding_name, SLUConfig_Encoding_value)
	proto.RegisterEnum("speechly.slu.v1.SLUEvent_Event", SLUEvent_Event_name, SLUEvent_Event_value)
	proto.RegisterType((*SLURequest)(nil), "speechly.slu.v1.SLURequest")
	proto.RegisterType((*SLUConfig)(nil), "speechly.slu.v1.SLUConfig")
	proto.RegisterType((*SLUEvent)(nil), "speechly.slu.v1.SLUEvent")
	proto.RegisterType((*SLUResponse)(nil), "speechly.slu.v1.SLUResponse")
	proto.RegisterType((*SLUTranscript)(nil), "speechly.slu.v1.SLUTranscript")
	proto.RegisterType((*SLUEntity)(nil), "speechly.slu.v1.SLUEntity")
	proto.RegisterType((*SLUIntent)(nil), "speechly.slu.v1.SLUIntent")
	proto.RegisterType((*SLUSegmentEnd)(nil), "speechly.slu.v1.SLUSegmentEnd")
	proto.RegisterType((*SLUTentativeTranscript)(nil), "speechly.slu.v1.SLUTentativeTranscript")
	proto.RegisterType((*SLUTentativeEntities)(nil), "speechly.slu.v1.SLUTentativeEntities")
	proto.RegisterType((*SLUStarted)(nil), "speechly.slu.v1.SLUStarted")
	proto.RegisterType((*SLUFinished)(nil), "speechly.slu.v1.SLUFinished")
	proto.RegisterType((*SLUError)(nil), "speechly.slu.v1.SLUError")
}

func init() { proto.RegisterFile("slu.proto", fileDescriptor_b3c6a5efd6c2ea4f) }

var fileDescriptor_b3c6a5efd6c2ea4f = []byte{
	// 886 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xb6, 0x69, 0xdd, 0xda, 0x27, 0xe9, 0xdf, 0xd9, 0xa8, 0xf2, 0x96, 0x12, 0x8a, 0xcb, 0x8a,
	0x8a, 0x8b, 0x40, 0xcb, 0xaf, 0xb8, 0x00, 0xda, 0x2a, 0x34, 0x95, 0xaa, 0x65, 0x35, 0x49, 0x41,
	0x42, 0x48, 0x96, 0x89, 0xcf, 0xa6, 0x96, 0x92, 0x71, 0xf0, 0x4c, 0xca, 0x2e, 0xb7, 0xbc, 0x00,
	0x17, 0x3c, 0x01, 0x4f, 0xc3, 0x05, 0x17, 0x2b, 0x71, 0xc3, 0x25, 0x6a, 0x5f, 0x04, 0xcd, 0x8f,
	0xdd, 0x6e, 0x71, 0xca, 0xde, 0x44, 0x99, 0x33, 0xdf, 0x77, 0xce, 0x99, 0xcf, 0xdf, 0x9c, 0x81,
	0x40, 0x8c, 0x67, 0x9d, 0x69, 0x91, 0xcb, 0x1c, 0xd7, 0xc4, 0x94, 0x68, 0x78, 0x31, 0x7e, 0xde,
	0x51, 0xb1, 0xcb, 0xfd, 0xe8, 0x77, 0x17, 0xa0, 0x7f, 0x76, 0xce, 0xe8, 0xc7, 0x19, 0x09, 0x89,
	0x1f, 0xc2, 0xd2, 0x30, 0xe7, 0x4f, 0xb3, 0x51, 0xe8, 0xee, 0xb8, 0x7b, 0x8d, 0x83, 0xad, 0xce,
	0x1d, 0x42, 0xa7, 0x7f, 0x76, 0x7e, 0xac, 0x11, 0x3d, 0x87, 0x59, 0x2c, 0xee, 0x83, 0x47, 0x97,
	0xc4, 0x65, 0xf8, 0x9a, 0x26, 0x3d, 0xac, 0x23, 0x75, 0x15, 0xa0, 0xe7, 0x30, 0x83, 0xc4, 0x4d,
	0xf0, 0x92, 0x59, 0x9a, 0xe5, 0xe1, 0xc2, 0x8e, 0xbb, 0xd7, 0x54, 0x71, 0xbd, 0x3c, 0x7a, 0x00,
	0x1b, 0x42, 0x16, 0x94, 0x4c, 0x32, 0x3e, 0x8a, 0x0b, 0xd3, 0x55, 0xf4, 0x97, 0x0b, 0x41, 0x55,
	0x17, 0xbf, 0x00, 0x9f, 0xf8, 0x30, 0x4f, 0x33, 0x6e, 0xba, 0x5c, 0x3d, 0xd8, 0x9d, 0xdf, 0x65,
	0xa7, 0x6b, 0xa1, 0xac, 0x22, 0xe1, 0x16, 0xf8, 0xc3, 0x8b, 0x84, 0x73, 0x1a, 0x0b, 0xdd, 0xb1,
	0xc7, 0xaa, 0x35, 0xbe, 0x0b, 0x1b, 0x22, 0x99, 0x4c, 0xc7, 0x14, 0x17, 0x89, 0xa4, 0xf8, 0x82,
	0x0a, 0xf9, 0xb3, 0xee, 0xd1, 0x63, 0x6b, 0x66, 0x83, 0x25, 0x92, 0x7a, 0x2a, 0x8c, 0xbb, 0xb0,
	0x32, 0x4e, 0xf8, 0x68, 0x96, 0x8c, 0x28, 0x1e, 0xe6, 0x29, 0x85, 0x8b, 0x3b, 0xee, 0x5e, 0xc0,
	0x9a, 0x65, 0xf0, 0x38, 0x4f, 0x29, 0x0a, 0xc1, 0x2f, 0x5b, 0xc0, 0x26, 0xf8, 0x67, 0xa7, 0x8f,
	0xbb, 0x87, 0x6c, 0xff, 0xe3, 0x75, 0x27, 0x8a, 0xc1, 0x2f, 0x75, 0xc1, 0x8f, 0x4a, 0x05, 0xcd,
	0x81, 0xde, 0x9c, 0xab, 0x60, 0x47, 0xff, 0x5a, 0x15, 0xa3, 0x6d, 0xf0, 0x0c, 0x3f, 0x00, 0xaf,
	0x3f, 0x38, 0x64, 0x83, 0x75, 0x07, 0x7d, 0x58, 0xec, 0x0f, 0xbe, 0x7e, 0xb2, 0xee, 0x46, 0x7f,
	0x7a, 0xd0, 0xd0, 0xdf, 0x56, 0x4c, 0x73, 0x2e, 0x48, 0xf5, 0xab, 0x45, 0x8e, 0x87, 0x39, 0x97,
	0xf4, 0xcc, 0x14, 0x0b, 0x58, 0x53, 0x07, 0x8f, 0x4d, 0x0c, 0xdf, 0x00, 0x10, 0x34, 0x9a, 0x10,
	0x97, 0x71, 0x96, 0x5a, 0x79, 0x02, 0x1b, 0x39, 0x4d, 0xf1, 0x4b, 0x00, 0x59, 0x24, 0x5c, 0x0c,
	0x8b, 0x6c, 0x2a, 0xb5, 0x30, 0x8d, 0x83, 0x76, 0x5d, 0xb7, 0x83, 0x0a, 0xd5, 0x73, 0xd8, 0x2d,
	0x8e, 0xb2, 0x18, 0x71, 0x99, 0xc9, 0xe7, 0x5a, 0xae, 0x39, 0x16, 0xeb, 0x6a, 0x84, 0xb2, 0x98,
	0xc1, 0x2a, 0x56, 0xc6, 0xa5, 0x52, 0xc8, 0x9b, 0xcf, 0x3a, 0xd5, 0x08, 0xc5, 0x32, 0x58, 0x3c,
	0x84, 0x46, 0x79, 0x18, 0xe2, 0x69, 0xb8, 0x34, 0xbf, 0xdd, 0xbe, 0x81, 0x75, 0x79, 0xaa, 0xda,
	0x15, 0xd5, 0x0a, 0xbf, 0x87, 0x96, 0x4a, 0x95, 0xc8, 0xec, 0x92, 0xe2, 0x5b, 0x47, 0x5f, 0xd6,
	0xb9, 0xde, 0xa9, 0x3d, 0x7a, 0x89, 0x7f, 0x49, 0x83, 0x07, 0xf2, 0xbf, 0x61, 0xfc, 0x06, 0xf0,
	0x26, 0xbb, 0x3e, 0x6a, 0x46, 0x22, 0xf4, 0x75, 0xee, 0x47, 0xf7, 0xe6, 0xee, 0x5a, 0x70, 0xcf,
	0x61, 0x1b, 0xf2, 0x6e, 0x10, 0x4f, 0x60, 0xfd, 0x26, 0xaf, 0x15, 0x2e, 0x78, 0x05, 0xe1, 0xd6,
	0x2a, 0x96, 0x09, 0xe1, 0x27, 0xb0, 0x2c, 0x64, 0x52, 0x48, 0x4a, 0x43, 0xd0, 0xfc, 0xd7, 0x6b,
	0xd5, 0x33, 0x90, 0x9e, 0xc3, 0x4a, 0x34, 0x7e, 0x06, 0xfe, 0xd3, 0x8c, 0x67, 0xe2, 0x82, 0xd2,
	0xb0, 0xa1, 0x99, 0xdb, 0x75, 0xcc, 0xaf, 0x2c, 0xa6, 0xe7, 0xb0, 0x0a, 0x7f, 0xd4, 0x02, 0xbc,
	0x3d, 0x04, 0x8c, 0x7d, 0x23, 0x01, 0x2b, 0x2f, 0xf9, 0x0a, 0x11, 0x16, 0x7f, 0xca, 0x8b, 0xd4,
	0xda, 0x58, 0xff, 0xc7, 0x16, 0x78, 0x19, 0x4f, 0xe9, 0x99, 0x75, 0xae, 0x59, 0x68, 0x53, 0xab,
	0xbe, 0x62, 0x99, 0x4d, 0xc8, 0x5e, 0xe7, 0x40, 0x47, 0x06, 0xd9, 0x84, 0xf0, 0xa1, 0x9a, 0x28,
	0xa9, 0xd9, 0x5c, 0xd4, 0x9b, 0xcb, 0xc4, 0x53, 0xb5, 0x15, 0xfd, 0x62, 0x46, 0x8f, 0xf1, 0x23,
	0x6e, 0x56, 0xde, 0x35, 0x35, 0x4b, 0x77, 0xb6, 0xc0, 0xbb, 0x4c, 0xc6, 0x33, 0xd2, 0x55, 0x03,
	0x66, 0x16, 0xf8, 0x08, 0x56, 0x4d, 0xd5, 0x69, 0x2e, 0x32, 0x99, 0xe5, 0xdc, 0x56, 0x5e, 0xd1,
	0xd1, 0x27, 0x36, 0x88, 0x6f, 0x41, 0x53, 0x55, 0xaf, 0x40, 0xa6, 0x83, 0x06, 0xf1, 0xb4, 0x84,
	0x44, 0xbb, 0xba, 0x09, 0xfb, 0x49, 0x36, 0xab, 0xab, 0x60, 0x9b, 0x30, 0xab, 0x68, 0x4d, 0xeb,
	0x73, 0x63, 0xe4, 0xe8, 0x37, 0x17, 0x36, 0xeb, 0xed, 0x88, 0xfb, 0x73, 0x5c, 0x6d, 0x32, 0xd6,
	0x5a, 0xf5, 0x04, 0x6e, 0xcc, 0x11, 0x2b, 0xad, 0xd5, 0xf0, 0x5c, 0xf8, 0xff, 0xeb, 0xcf, 0x56,
	0x2b, 0xda, 0xb7, 0x8a, 0x15, 0x25, 0xd0, 0xaa, 0x33, 0x32, 0x9e, 0xd6, 0xde, 0x05, 0x57, 0xd7,
	0xb8, 0x67, 0x48, 0xd4, 0xd8, 0x3f, 0x6a, 0xea, 0x47, 0xcd, 0xba, 0x32, 0xfa, 0x5c, 0x8f, 0xc1,
	0xd2, 0x69, 0xf8, 0x1e, 0x78, 0x54, 0x14, 0x79, 0x71, 0xef, 0x6b, 0xa5, 0x00, 0xcc, 0xe0, 0xa2,
	0x4f, 0xcd, 0xa0, 0x56, 0xff, 0x95, 0xe7, 0xf4, 0xa8, 0xb7, 0x9e, 0x53, 0xff, 0x31, 0x84, 0xe5,
	0x09, 0x09, 0x91, 0x8c, 0xca, 0xef, 0x5f, 0x2e, 0x0f, 0x1e, 0xc3, 0x42, 0xff, 0xec, 0x1c, 0x4f,
	0x60, 0xa9, 0xaf, 0xfd, 0x8c, 0xb5, 0xb7, 0xc7, 0x3e, 0xbe, 0x5b, 0xdb, 0xf5, 0x9b, 0xc6, 0xfe,
	0x7b, 0xee, 0xfb, 0xee, 0xd1, 0xdb, 0x7f, 0x5c, 0xb5, 0xdd, 0x17, 0x57, 0x6d, 0xf7, 0x9f, 0xab,
	0xb6, 0xfb, 0xeb, 0x75, 0xdb, 0x79, 0x71, 0xdd, 0x76, 0xfe, 0xbe, 0x6e, 0x3b, 0x3d, 0xf7, 0x3b,
	0xbf, 0x24, 0xff, 0xb0, 0xa4, 0xdf, 0xfa, 0x0f, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xdd, 0xd9,
	0xa2, 0xb7, 0xf8, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SLUClient is the client API for SLU service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SLUClient interface {
	// Starts an SLU bidirectional stream,
	// the input and output messages explains the details of the call.
	Stream(ctx context.Context, opts ...grpc.CallOption) (SLU_StreamClient, error)
}

type sLUClient struct {
	cc *grpc.ClientConn
}

func NewSLUClient(cc *grpc.ClientConn) SLUClient {
	return &sLUClient{cc}
}

func (c *sLUClient) Stream(ctx context.Context, opts ...grpc.CallOption) (SLU_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLU_serviceDesc.Streams[0], "/speechly.slu.v1.SLU/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLUStreamClient{stream}
	return x, nil
}

type SLU_StreamClient interface {
	Send(*SLURequest) error
	Recv() (*SLUResponse, error)
	grpc.ClientStream
}

type sLUStreamClient struct {
	grpc.ClientStream
}

func (x *sLUStreamClient) Send(m *SLURequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLUStreamClient) Recv() (*SLUResponse, error) {
	m := new(SLUResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SLUServer is the server API for SLU service.
type SLUServer interface {
	// Starts an SLU bidirectional stream,
	// the input and output messages explains the details of the call.
	Stream(SLU_StreamServer) error
}

// UnimplementedSLUServer can be embedded to have forward compatible implementations.
type UnimplementedSLUServer struct {
}

func (*UnimplementedSLUServer) Stream(srv SLU_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}

func RegisterSLUServer(s *grpc.Server, srv SLUServer) {
	s.RegisterService(&_SLU_serviceDesc, srv)
}

func _SLU_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLUServer).Stream(&sLUStreamServer{stream})
}

type SLU_StreamServer interface {
	Send(*SLUResponse) error
	Recv() (*SLURequest, error)
	grpc.ServerStream
}

type sLUStreamServer struct {
	grpc.ServerStream
}

func (x *sLUStreamServer) Send(m *SLUResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLUStreamServer) Recv() (*SLURequest, error) {
	m := new(SLURequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SLU_serviceDesc = grpc.ServiceDesc{
	ServiceName: "speechly.slu.v1.SLU",
	HandlerType: (*SLUServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _SLU_Stream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "slu.proto",
}

func (m *SLURequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLURequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLURequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StreamingRequest != nil {
		{
			size := m.StreamingRequest.Size()
			i -= size
			if _, err := m.StreamingRequest.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SLURequest_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLURequest_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SLURequest_Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLURequest_Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SLURequest_Audio) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLURequest_Audio) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Audio != nil {
		i -= len(m.Audio)
		copy(dAtA[i:], m.Audio)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.Audio)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SLUConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LanguageCode) > 0 {
		i -= len(m.LanguageCode)
		copy(dAtA[i:], m.LanguageCode)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.LanguageCode)))
		i--
		dAtA[i] = 0x22
	}
	if m.SampleRateHertz != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.SampleRateHertz))
		i--
		dAtA[i] = 0x18
	}
	if m.Channels != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.Channels))
		i--
		dAtA[i] = 0x10
	}
	if m.Encoding != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.Encoding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SLUEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.Event))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SLUResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StreamingResponse != nil {
		{
			size := m.StreamingResponse.Size()
			i -= size
			if _, err := m.StreamingResponse.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SegmentId != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.SegmentId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AudioContext) > 0 {
		i -= len(m.AudioContext)
		copy(dAtA[i:], m.AudioContext)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.AudioContext)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SLUResponse_Transcript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse_Transcript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Transcript != nil {
		{
			size, err := m.Transcript.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SLUResponse_Entity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse_Entity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Entity != nil {
		{
			size, err := m.Entity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SLUResponse_Intent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse_Intent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Intent != nil {
		{
			size, err := m.Intent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SLUResponse_SegmentEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse_SegmentEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SegmentEnd != nil {
		{
			size, err := m.SegmentEnd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SLUResponse_TentativeTranscript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse_TentativeTranscript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TentativeTranscript != nil {
		{
			size, err := m.TentativeTranscript.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *SLUResponse_TentativeEntities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse_TentativeEntities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TentativeEntities != nil {
		{
			size, err := m.TentativeEntities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *SLUResponse_TentativeIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse_TentativeIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TentativeIntent != nil {
		{
			size, err := m.TentativeIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *SLUResponse_Started) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse_Started) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *SLUResponse_Finished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUResponse_Finished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *SLUTranscript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUTranscript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUTranscript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndTime != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x20
	}
	if m.StartTime != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Word) > 0 {
		i -= len(m.Word)
		copy(dAtA[i:], m.Word)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.Word)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SLUEntity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUEntity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUEntity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndPosition != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.EndPosition))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPosition != 0 {
		i = encodeVarintSlu(dAtA, i, uint64(m.StartPosition))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Entity) > 0 {
		i -= len(m.Entity)
		copy(dAtA[i:], m.Entity)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.Entity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SLUIntent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Intent) > 0 {
		i -= len(m.Intent)
		copy(dAtA[i:], m.Intent)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.Intent)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SLUSegmentEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUSegmentEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUSegmentEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SLUTentativeTranscript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUTentativeTranscript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUTentativeTranscript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TentativeWords) > 0 {
		for iNdEx := len(m.TentativeWords) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TentativeWords[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TentativeTranscript) > 0 {
		i -= len(m.TentativeTranscript)
		copy(dAtA[i:], m.TentativeTranscript)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.TentativeTranscript)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SLUTentativeEntities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUTentativeEntities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUTentativeEntities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TentativeEntities) > 0 {
		for iNdEx := len(m.TentativeEntities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TentativeEntities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SLUStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SLUFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SLUError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SLUError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SLUError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintSlu(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSlu(dAtA []byte, offset int, v uint64) int {
	offset -= sovSlu(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SLURequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamingRequest != nil {
		n += m.StreamingRequest.Size()
	}
	return n
}

func (m *SLURequest_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLURequest_Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLURequest_Audio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Audio != nil {
		l = len(m.Audio)
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Encoding != 0 {
		n += 1 + sovSlu(uint64(m.Encoding))
	}
	if m.Channels != 0 {
		n += 1 + sovSlu(uint64(m.Channels))
	}
	if m.SampleRateHertz != 0 {
		n += 1 + sovSlu(uint64(m.SampleRateHertz))
	}
	l = len(m.LanguageCode)
	if l > 0 {
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}

func (m *SLUEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != 0 {
		n += 1 + sovSlu(uint64(m.Event))
	}
	return n
}

func (m *SLUResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AudioContext)
	if l > 0 {
		n += 1 + l + sovSlu(uint64(l))
	}
	if m.SegmentId != 0 {
		n += 1 + sovSlu(uint64(m.SegmentId))
	}
	if m.StreamingResponse != nil {
		n += m.StreamingResponse.Size()
	}
	return n
}

func (m *SLUResponse_Transcript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transcript != nil {
		l = m.Transcript.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUResponse_Entity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entity != nil {
		l = m.Entity.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUResponse_Intent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Intent != nil {
		l = m.Intent.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUResponse_SegmentEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SegmentEnd != nil {
		l = m.SegmentEnd.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUResponse_TentativeTranscript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TentativeTranscript != nil {
		l = m.TentativeTranscript.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUResponse_TentativeEntities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TentativeEntities != nil {
		l = m.TentativeEntities.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUResponse_TentativeIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TentativeIntent != nil {
		l = m.TentativeIntent.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUResponse_Started) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUResponse_Finished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}
func (m *SLUTranscript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Word)
	if l > 0 {
		n += 1 + l + sovSlu(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovSlu(uint64(m.Index))
	}
	if m.StartTime != 0 {
		n += 1 + sovSlu(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovSlu(uint64(m.EndTime))
	}
	return n
}

func (m *SLUEntity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Entity)
	if l > 0 {
		n += 1 + l + sovSlu(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSlu(uint64(l))
	}
	if m.StartPosition != 0 {
		n += 1 + sovSlu(uint64(m.StartPosition))
	}
	if m.EndPosition != 0 {
		n += 1 + sovSlu(uint64(m.EndPosition))
	}
	return n
}

func (m *SLUIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Intent)
	if l > 0 {
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}

func (m *SLUSegmentEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SLUTentativeTranscript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TentativeTranscript)
	if l > 0 {
		n += 1 + l + sovSlu(uint64(l))
	}
	if len(m.TentativeWords) > 0 {
		for _, e := range m.TentativeWords {
			l = e.Size()
			n += 1 + l + sovSlu(uint64(l))
		}
	}
	return n
}

func (m *SLUTentativeEntities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TentativeEntities) > 0 {
		for _, e := range m.TentativeEntities {
			l = e.Size()
			n += 1 + l + sovSlu(uint64(l))
		}
	}
	return n
}

func (m *SLUStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SLUFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}

func (m *SLUError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovSlu(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSlu(uint64(l))
	}
	return n
}

func sovSlu(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSlu(x uint64) (n int) {
	return sovSlu(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SLURequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLURequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLURequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingRequest = &SLURequest_Config{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingRequest = &SLURequest_Event{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.StreamingRequest = &SLURequest_Audio{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= SLUConfig_Encoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			m.Channels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleRateHertz", wireType)
			}
			m.SampleRateHertz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleRateHertz |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LanguageCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LanguageCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			m.Event = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Event |= SLUEvent_Event(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AudioContext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentId", wireType)
			}
			m.SegmentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transcript", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUTranscript{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingResponse = &SLUResponse_Transcript{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUEntity{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingResponse = &SLUResponse_Entity{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUIntent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingResponse = &SLUResponse_Intent{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUSegmentEnd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingResponse = &SLUResponse_SegmentEnd{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TentativeTranscript", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUTentativeTranscript{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingResponse = &SLUResponse_TentativeTranscript{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TentativeEntities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUTentativeEntities{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingResponse = &SLUResponse_TentativeEntities{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TentativeIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUIntent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingResponse = &SLUResponse_TentativeIntent{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingResponse = &SLUResponse_Started{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SLUFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamingResponse = &SLUResponse_Finished{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUTranscript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUTranscript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUTranscript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Word", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Word = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUEntity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUEntity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUEntity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosition", wireType)
			}
			m.StartPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPosition", wireType)
			}
			m.EndPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndPosition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUIntent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUIntent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUIntent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUSegmentEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUSegmentEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUSegmentEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUTentativeTranscript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUTentativeTranscript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUTentativeTranscript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TentativeTranscript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TentativeTranscript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TentativeWords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TentativeWords = append(m.TentativeWords, &SLUTranscript{})
			if err := m.TentativeWords[len(m.TentativeWords)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUTentativeEntities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUTentativeEntities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUTentativeEntities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TentativeEntities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TentativeEntities = append(m.TentativeEntities, &SLUEntity{})
			if err := m.TentativeEntities[len(m.TentativeEntities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &SLUError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SLUError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SLUError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SLUError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSlu(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSlu
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSlu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSlu
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSlu
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSlu
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSlu        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSlu          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSlu = fmt.Errorf("proto: unexpected end of group")
)
