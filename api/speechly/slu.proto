// MIT License
//
// Copyright (c) 2020, Speechly
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

syntax = "proto3";

package speechly.slu.v1;

option optimize_for = SPEED;
option go_package = "speechly";

// Speechly spoken language understanding service
//
// This service requires that the user has an accesstoken from
// `Identity` service. The token must be included in the metadata as
// `Authorization` key with value `Bearer TOKEN_HERE`.
service SLU {
  // Starts an SLU bidirectional stream,
  // the input and output messages explains the details of the call.
  rpc Stream(stream SLURequest) returns (stream SLUResponse);
}

// The message repeatedly sent by the client of `Slu.Stream`.
//
// When a new `Slu.Stream` stream is started, the client must first
// send the `config` value, which configures the SLU engine. If it is
// not the first message sent, the stream will close with an error.
//
// After the configuration has done, the stream is in an "audio loop"
// state. Where the user sends `event` messages as a control signal,
// e.g. to start and stop a single utterance. And the user streams
// audio as `audio` value when an utterance is ongoing.
//
// The basic audio loop is:
// - Client sends `SluEvent.Event.START` event when the user wants to
//   start speaking.
// - Server sends `SluResponse.started` when it's ready to receive
//   audio for an utterance.
// - Client sends audio chunks. Chunks must be under one megabyte.
// - Server sends `SluReponses` for events and utterance results.
// - Client sends `SluEvent.Event.STOP` event when no more audio is to
//   be sent for this utterance.
// - Server processed all audio received until stop, and sends
//   utterance results. Finishing with `finished response`.
//
// Only one utterance can be active at a time, but the old utterances
// can still concurrently send results.
//
// If `SluEvent.Event.START` is send before stopping the current
// on-going utterance with `SluEvent.Event.STOP` the whole stream is
// killed with an error. This is to ensure that the clients are well
// behaved.
//
// See `SLUResponse` for info on server sent messages.
message SLURequest {
  oneof streaming_request {
    SLUConfig config = 1;
    SLUEvent event = 2;
    bytes audio = 3;
  }
}

// Message to configure the speech recognition engine.
//
// This message must be sent as the first message in `Slu.Stream` RPC.
message SLUConfig {
  // Choice of audio encodings.
  enum Encoding {
    LINEAR16 = 0; // Raw linear 16-bit PCM audio.
  }

  // The encoding used for the audio stream, defaults to the first
  // item in `Encoding`.
  Encoding encoding = 1;

  // *Required* Channels in the audio stream, must be at least 1.
  int32 channels = 2;

  // *Required* Sample rate of the audio stream. 16000Hz is
  // preferred, 8000Hz is the minimum rate.
  int32 sample_rate_hertz = 3;

  // *Required* Language code for speech recognition. Must match one
  // of the languages defined in the appId configuration.
  string language_code = 4;
}

// Control event send by the client in `Slu.Stream` RPC.
message SLUEvent {
  enum Event {
    // Starts a new audio context
    START = 0;

    // Stops an audio context
    STOP = 1;
  }

  Event event = 1;
}

// Message sent by the server in `Slu.Stream` RPC.
//
// When an utterance is started, the server sends the `SluStarted`
// message, which contains an `audio_context` for matching rest of the
// response messages to that specific utterance.
//
// As the audio is processed, the server sends `TranscriptEvent` messages
// continuously.
//
// `SluFinished` is sent when an audio context is finished, either by the
// client stopping the utterance, or by an error.
message SLUResponse {
  // The identifier to match server responses to an audio context.
  string audio_context = 1;
  int32 segment_id = 2;

  oneof streaming_response {
    SLUTranscript transcript = 3;
    SLUEntity entity = 4;
    SLUIntent intent = 5;
    SLUSegmentEnd segment_end = 6;

    SLUTentativeTranscript tentative_transcript = 7;
    SLUTentativeEntities tentative_entities = 8;
    SLUIntent tentative_intent = 9;

    SLUStarted started = 10;
    SLUFinished finished = 11;
  }
}

message SLUTranscript {
  string word = 1;
  int32 index = 2;
  int32 start_time = 3;
  int32 end_time = 4;
}

message SLUEntity {
  string entity = 1;
  string value = 2;
  int32 start_position = 3;
  int32 end_position = 4;
}

message SLUIntent {
  string intent = 1;
}

message SLUSegmentEnd {}

message SLUTentativeTranscript {
  string tentative_transcript = 1;
  repeated SLUTranscript tentative_words = 2;
}

message SLUTentativeEntities {
  repeated SLUEntity tentative_entities = 1;
}

// Message sent when a new audio context has started.
message SLUStarted {}

// Message sent when an audio context is finished.
message SLUFinished {
  // If the audio context finished with an error, then this field contains a value.
  SLUError error = 2;
}

// Message for errors
message SLUError {
  // Short code for the error
  string code = 1;
  // Human readable explanation of the error
  string message = 2;
}
